# swap in and swap out 

为了实现虚拟内存 

虚拟内存是连接分段和分页的关键

分段和分页是OS进行内存管理的关键

---

用户眼中：大而规整的内存空间 —— 段 —— 假象 —— 虚拟内存

$\downarrow$

**映射**到物理内存

---

## swap in —— 请求调页

假设实际物理内存只有1G，那么，如何给用户提供一种“有4G内存的错觉”？—— 内存换入

<img src="img/swap_in_1G_4G.jpg"  align=center style="zoom:100%;" />

要使用用户眼中超过实际内存大小的虚拟地址空间时，将这段虚拟内存空间 **换入** 到物理内存——请求的时候换入并建立映射（因为物理空间的限制，无法将所有的虚拟内存段都载入到物理内存，无法全部在页表中映射） —— 请求调入页面并建立对页面的映射

**请求调页** ：用代码段举例：执行某条指令A，根据虚拟地址，MMU查页表，发现这条指令A的物理页地址没有映射到对应的页框号，进程无法继续执行，进行中断（每执行一条指令就会去看中断寄存器是否为1，为1就进行中断） -> 中断处理 -> 从磁盘中将这段内容读到空闲内存页中（换入），并建立页表映射，再去执行没执行完的指令A（并不是产生中断的指令的下一条指令） -> 用户在执行这条指令的时候可能会觉得慢了一点

<img src="img/request_page.jpg"  align=center style="zoom:100%;" />

> A question：为什么使用“请求调页”而不是“请求调段”？
>
> 因为：





