# swap in and swap out 

为了实现虚拟内存 

虚拟内存是连接分段和分页的关键

分段和分页是OS进行内存管理的关键

---

用户眼中：大而规整的内存空间 —— 段 —— 假象 —— 虚拟内存

$\downarrow$

**映射**到物理内存

---

## swap in —— 请求调页

假设实际物理内存只有1G，那么，如何给用户提供一种“有4G内存的错觉”？—— 内存换入

<img src="img/swap_in_1G_4G.jpg"  align=center style="zoom:100%;" />

要使用用户眼中超过实际内存大小的虚拟地址空间时，将这段虚拟内存空间 **换入** 到物理内存——请求的时候换入并建立映射（因为物理空间的限制，无法将所有的虚拟内存段都载入到物理内存，无法全部在页表中映射） —— 请求调入页面并建立对页面的映射

**请求调页** ：用代码段举例：执行某条指令A，根据虚拟地址，MMU查页表，发现这条指令A的物理页地址没有映射到对应的页框号，进程无法继续执行，进行中断（每执行一条指令就会去看中断寄存器是否为1，为1就进行中断） -> 中断处理 -> 从磁盘中将这段内容读到空闲内存页中（换入），并建立页表映射，再去执行没执行完的指令A（并不是产生中断的指令的下一条指令） -> 用户在执行这条指令的时候可能会觉得慢了一点

<img src="img/request_page.jpg"  align=center style="zoom:100%;" />

> A question：为什么使用“请求调页”而不是“请求调段”？
>
> 因为：

---

### 代码实现swap_in

从“中断“开始


```s
.globl
page_fault:
    
    ...
    
```

核心代码：

```c
void do_no_page(unsigned long error_code, unsigned long address)
{
    ...

    page = get_free_page();
    // 1. 申请页
    bread_page(page, current->executable->i_dev, nr);
    // 2. 从磁盘把程序装入页 —— 读文件系统
    put_page(page, address);
    // 3. 将虚拟内存和物理内存关联起来（填写页表）

    ...
}
```



## swap out

> 重点：LRU算法

有换出，物理内存才不会一直是满的 —— 空出地方，放置新的程序

换出发生在 `get_free_page` 中


--- 

### 换出算法：

1. FIFO页面置换

<img src="img/swap_FIFO.jpg"  align=center style="zoom:100%;" />

