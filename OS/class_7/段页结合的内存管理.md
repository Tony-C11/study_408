# 段页结合的内存管理


## 分段存储 —— 分区 —— 虚拟内存采用的方法


将程序分成：
1. 数据段
2. 代码段
3. 堆栈段
4. ...

内存分区：在内存中找到空闲的区域分给进程段 —— 内存分割

可变分区：

```shell

段请求 -> 

                +----------------
                |   区域1
                |
                +----------------
                |
                |
                |   区域2
                |
                +----------------
                |   区域3
                +----------------

        

```


建立段表：

|   段号    |   段基址  |
|   ---     |   ---     |
|   0       |   0x...   |
|   1       |   0x...   |
|   2       |   0x...   |
|   3       |   0x...   |

---

设置两类数据结构：

- 记录已使用的分区

> |   起始地址    |   大小    |
> |   ---         |   ---     |
> |   ...         |   ...     |

- 记录空闲区域

> |   起始地址    |   大小    |
> |   ---         |   ---     |
> |   ...         |   ...     |

---

分区算法：

1. 最优适配：从最接近段请求的空闲空间中分配空间 —— 每次都会剩下一些小块内存
2. 最差适配：从最大的空闲空间中分出空间 —— 每次都能剩下大块内存，但可能无法给很大的进程分配内存空间
3. 首先适配：从表中查到的第一个足够大的空闲空间分配

---

将程序分段后直接放入物理内存 —— 分区，会造成外部碎片（空闲但不连续的小块空间，无法分配给其他段（段连续），造成内存浪费），所以，虚拟内存使用分区，而实际上物理内存采用分页的方式来划分内存并存储进程，分页产生的碎片很小（ < 4K）


## 分页

采用分页，需要在内存中建立页表：

> 页指针：CR3 指向 存储页表的内存地址
> |   （逻辑）页号    |   页框号（页框号 * 4K = 物理页的起始地址）|
> |   ---             |   ---                                     |
> |   ...             |   ...                                     |
> 根据页号查页表（通过进程对应的CR3找到页表位置）找到页框号，算出物理页的起始地址

但这时又有了新的问题：每个页都有对应的页框号，如果都记录在页表内，那建立的页表会占据大量内存（2^32 位地址空间需要记录 2^20 个页号），所以，为了节约内存，引入**多级页表** 。

典型的二级页表类似于：
```shell
1. A            - 页目录号
    1.1 a0      - 页号
    1.2 a1
    1.3 a2
    ...

2. B
    2.1 b0
    2.2 b1
    2.3 b2
    ...

...

```

```shell
页目录表：存放指向页表的指针
+---------------+
|ptr_page_table1|   ->  NULL
+---------------+
|ptr_page_table2|   ->  NULL
+---------------+
|ptr_page_table3|   ->  0x...
+---------------+
|ptr_page_table4|   ->  NULL
+---------------+
|ptr_page_table5|   ->  0x...
+---------------+
|...            |   ->  ...

根据页目录号找到需要的页表，
页目录号存放的位置 = 指向页目录表的指针 + （页目录号 * 4），因为用4Byte的内存空间来存储一个页目录号（这句话的正确性待定）

CTR3 = ptr_page_table2

ptr_page_table2：
+----+------
|页号|页框号
+----+------
|0   |4     
+----+------
|1   |1     
+----+------
|2   |8     
+----+------
|3   |2     
+----+------
|4   |5     
+----+------
|... |...   

根据页号找到页框号，算出物理页的地址，再 + OFFSET

```

采用多级页表的好处：
1. 页表连续，便于查询：页目录是连续的
2. 相比一级页表，节省了空间：根据页目录表寻址页表，给用到的页表分配空间，没用到的页表虽然有页目录号，但是没有为这些页表分配空间

> 但每次访问页目录表，再访问页表，都是在进行内存访问，为了加快匹配速度，引入“快表（寄存器）”->基于**局部性**原理


用户希望的是程序分段，而实际在物理内存上是将程序各个段“打散”成**页（4K/页）**，分配到不同的物理内存页表上。所以，引入**虚拟内存**，进行中转。

> 这就造成程序段在逻辑上是线性的，但在实际物理内存上是链式的

---

完成虚拟内存到物理内存转换的是MMU（Memory Manage Unit）：


```shell
Vitrual_Address: 32bit

32        22        12         1
+---------+---------+----------+
| 10bit   | 10bit   |   12bit  |
+---------+---------+----------+
 页目录号    页表号    OFFSET
```

程序中给出偏移量，根据段号查询段表，找到段基址 ->根据段基址查物理算出页号 -> 根据页号查页表，找出页框号 -> 页框号 * 4K = 物理内存页的起始地址，再加上偏移量，算出具体物理地址
